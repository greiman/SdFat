diff --git a/examples/debug/CardBusyTest/CardBusyTest.ino b/examples/debug/CardBusyTest/CardBusyTest.ino
index c9db8a3..b38599b 100644
--- a/examples/debug/CardBusyTest/CardBusyTest.ino
+++ b/examples/debug/CardBusyTest/CardBusyTest.ino
@@ -98,6 +98,8 @@ void loop() {
       maxWrite = m;
     }
   }
+  // Remove any extra space in the file.
+  file.truncate();
   file.close();
   ms = millis() - ms;
   Serial.println(F("\nTimes in micros"));

diff --git a/src/ExFatLib/ExFatDbg.cpp b/src/ExFatLib/ExFatDbg.cpp
index a8492f7..8b0f330 100644
--- a/src/ExFatLib/ExFatDbg.cpp
+++ b/src/ExFatLib/ExFatDbg.cpp
@@ -399,14 +399,14 @@ void ExFatPartition::dmpFat(print_t* pr, uint32_t start, uint32_t count) {
   }
 }
 //------------------------------------------------------------------------------
-void ExFatPartition::dmpSector(print_t* pr, uint32_t sector) {
+void ExFatPartition::dmpSector(print_t* pr, Sector_t sector, uint8_t w) {
-  uint8_t* cache = dataCachePrepare(sector, FsCache::CACHE_FOR_READ);
+  const uint8_t* cache = dataCachePrepare(sector, FsCache::CACHE_FOR_READ);
   if (!cache) {
     pr->println(F("dmpSector failed"));
     return;
   }
   for (uint16_t i = 0; i < m_bytesPerSector; i++) {
-    if (i % 32 == 0) {
+    if (i % w == 0) {
       if (i) {
         pr->println();
       }
diff --git a/src/ExFatLib/ExFatFile.cpp b/src/ExFatLib/ExFatFile.cpp
index 1650a70..03b195c 100644
--- a/src/ExFatLib/ExFatFile.cpp
+++ b/src/ExFatLib/ExFatFile.cpp
@@ -88,7 +88,7 @@ bool ExFatFile::contiguousRange(Sector_t* bgnSector, Sector_t* endSector) {
   }
   if (endSector) {
     *endSector =
-        firstSector() + ((m_validLength - 1) >> m_vol->bytesPerSectorShift());
+        firstSector() + ((m_dataLength - 1) >> m_vol->bytesPerSectorShift());
   }
   return true;
 }
@@ -576,7 +576,10 @@ int ExFatFile::peek() {
 int ExFatFile::read(void* buf, size_t count) {
   uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
   int8_t fg;
-  size_t toRead = count;
+  uint64_t maxRead;
+  size_t toRead;
+  size_t toFill;
+  size_t rtn = 0;
   size_t n;
   uint8_t* cache;
   uint16_t sectorOffset;
@@ -588,9 +591,15 @@ int ExFatFile::read(void* buf, size_t count) {
     goto fail;
   }
   if (isContiguous() || isFile()) {
-    if ((m_curPosition + count) > m_validLength) {
-      count = toRead = m_validLength - m_curPosition;
+    if (count > (m_dataLength - m_curPosition)) {
+      count = m_dataLength - m_curPosition;
     }
+    maxRead = m_curPosition < m_validLength ? m_validLength - m_curPosition : 0;
+    toRead = count < maxRead ? count : maxRead;
+    toFill = count > toRead ? count - toRead : 0;
+  } else {
+    toRead = count;
+    toFill = 0;
   }
   while (toRead) {
     clusterOffset = m_curPosition & m_vol->clusterMask();
@@ -657,10 +666,16 @@ int ExFatFile::read(void* buf, size_t count) {
       }
     }
     dst += n;
+    rtn += n;
     m_curPosition += n;
     toRead -= n;
   }
-  return count - toRead;
+  if (toFill) {
+    memset(dst, 0, toFill);
+    seekCur(toFill);
+    rtn += toFill;
+  }
+  return rtn;
 
 fail:
   m_error |= READ_ERROR;
@@ -698,7 +713,7 @@ bool ExFatFile::seekSet(uint64_t pos) {
     goto done;
   }
   if (isFile()) {
-    if (pos > m_validLength) {
+    if (pos > m_dataLength) {
       DBG_FAIL_MACRO;
       goto fail;
     }
diff --git a/src/ExFatLib/ExFatFile.h b/src/ExFatLib/ExFatFile.h
index a69b3fa..40f4933 100644
--- a/src/ExFatLib/ExFatFile.h
+++ b/src/ExFatLib/ExFatFile.h
@@ -207,6 +207,8 @@ class ExFatFile {
   uint64_t dataLength() const { return m_dataLength; }
   /** \return Directory entry index. */
   uint32_t dirIndex() const { return m_dirPos.position / FS_DIR_SIZE; }
+  /** \return The first cluster number for a file or directory. */
+  Cluster_t firstCluster() const { return m_firstCluster; }
   /** Test for the existence of a file in a directory
    *
    * \param[in] path Path of the file to be tested for.
@@ -249,7 +249,7 @@ class ExFatFile {
    */
-  int fgets(char* str, int num, char* delim = nullptr);
+  int fgets(char* str, int num, const char* delim = nullptr);
   /** \return The total number of bytes in a file. */
-  uint64_t fileSize() const { return m_validLength; }
+  uint64_t fileSize() const { return m_dataLength; }
   /** \return Address of first sector or zero for empty file. */
-  uint32_t firstSector() const;
+  Sector_t firstSector() const;
   /** Set position for streams
@@ -712,7 +714,7 @@ class ExFatFile {
    * \return true for success or false for failure.
    */
   bool seekEnd(int64_t offset = 0) {
-    return isFile() ? seekSet(m_validLength + offset) : false;
+    return isFile() ? seekSet(m_dataLength + offset) : false;
   }
   /** Sets a file's position.
    *
diff --git a/src/ExFatLib/ExFatFilePrint.cpp b/src/ExFatLib/ExFatFilePrint.cpp
index cd350bd..6664b47 100644
--- a/src/ExFatLib/ExFatFilePrint.cpp
+++ b/src/ExFatLib/ExFatFilePrint.cpp
@@ -117,7 +117,7 @@ size_t ExFatFile::printCreateDateTime(print_t* pr) {
 }
 //------------------------------------------------------------------------------
 size_t ExFatFile::printFileSize(print_t* pr) {
-  uint64_t n = m_validLength;
+  uint64_t n = fileSize();
   char buf[21];
   char* str = &buf[sizeof(buf) - 1];
   char* bgn = str - 12;
diff --git a/src/ExFatLib/ExFatFileWrite.cpp b/src/ExFatLib/ExFatFileWrite.cpp
index 28c1c68..cd7ea8b 100644
--- a/src/ExFatLib/ExFatFileWrite.cpp
+++ b/src/ExFatLib/ExFatFileWrite.cpp
@@ -587,8 +587,8 @@ bool ExFatFile::truncate() {
       }
     }
   }
+  m_validLength = m_curPosition > m_validLength ? m_validLength : m_curPosition;
   m_dataLength = m_curPosition;
-  m_validLength = m_curPosition;
   m_flags |= FILE_FLAG_DIR_DIRTY;
   return sync();
 
@@ -605,10 +605,10 @@ size_t ExFatFile::write(const void* buf, size_t nbyte) {
   uint16_t sectorOffset;
-  uint32_t sector;
+  Sector_t sector;
   uint32_t clusterOffset;
-
-  // number of bytes left to write  -  must be before goto statements
+  uint64_t toFill = 0;
   size_t toWrite = nbyte;
   size_t n;
+
   // error if not an open file or is read-only
   if (!isWritable()) {
     DBG_FAIL_MACRO;
@@ -615,7 +615,14 @@ size_t ExFatFile::write(const void* buf, size_t nbyte) {
   }
   // seek to end of file if append flag
   if ((m_flags & FILE_FLAG_APPEND)) {
-    if (!seekSet(m_validLength)) {
+    if (!seekSet(m_dataLength)) {
+      DBG_FAIL_MACRO;
+      goto fail;
+    }
+  }
+  if (m_curPosition > m_validLength) {
+    toFill = m_curPosition - m_validLength;
+     if (!seekSet(m_validLength)) {
       DBG_FAIL_MACRO;
       goto fail;
     }
@@ -668,14 +675,10 @@ size_t ExFatFile::write(const void* buf, size_t nbyte) {
     sector = m_vol->clusterStartSector(m_curCluster) +
              (clusterOffset >> m_vol->bytesPerSectorShift());
 
-    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
+    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector() || toFill) {
       // partial sector - must use cache
       // max space in sector
       n = m_vol->bytesPerSector() - sectorOffset;
-      // lesser of space and amount to write
-      if (n > toWrite) {
-        n = toWrite;
-      }
 
       if (sectorOffset == 0 && m_curPosition >= m_validLength) {
         // start of new sector don't need to read into cache
@@ -690,7 +693,18 @@ size_t ExFatFile::write(const void* buf, size_t nbyte) {
         goto fail;
       }
       uint8_t* dst = cache + sectorOffset;
-      memcpy(dst, src, n);
+
+      if (toFill) {
+        if (n > toFill) {
+          n = toFill;
+        }
+        memset(dst, 0, n);
+      } else {
+        if (n > toWrite) {
+          n = toWrite;
+        }
+        memcpy(dst, src, n);
+      }
       if (m_vol->bytesPerSector() == (n + sectorOffset)) {
         // Force write if sector is full - improves large writes.
         if (!m_vol->dataCacheSync()) {
@@ -722,8 +736,12 @@ size_t ExFatFile::write(const void* buf, size_t nbyte) {
       }
     }
     m_curPosition += n;
-    src += n;
-    toWrite -= n;
+    if (toFill) {
+      toFill -= n;
+    } else {
+      src += n;
+      toWrite -= n;
+    }
     if (m_curPosition > m_validLength) {
       m_flags |= FILE_FLAG_DIR_DIRTY;
       m_validLength = m_curPosition;
diff --git a/src/ExFatLib/ExFatPartition.h b/src/ExFatLib/ExFatPartition.h
index 5114d3d..149a434 100644
--- a/src/ExFatLib/ExFatPartition.h
+++ b/src/ExFatLib/ExFatPartition.h
@@ -130,8 +130,8 @@ class ExFatPartition {
   void dmpBitmap(print_t* pr);
-  void dmpCluster(print_t* pr, uint32_t cluster, uint32_t offset,
+  void dmpCluster(print_t* pr, Cluster_t cluster, uint32_t offset,
                   uint32_t count);
   void dmpFat(print_t* pr, uint32_t start, uint32_t count);
-  void dmpSector(print_t* pr, uint32_t sector);
+  void dmpSector(print_t* pr, Sector_t sector, uint8_t w = 16);
   bool printVolInfo(print_t* pr);
   void printFat(print_t* pr);
   void printUpcase(print_t* pr);
diff --git a/src/FatLib/FatFile.h b/src/FatLib/FatFile.h
index 019d6d4..df9df53 100644
--- a/src/FatLib/FatFile.h
+++ b/src/FatLib/FatFile.h
@@ -331,6 +331,8 @@ class FatFile {
    * occurred.
    */
-  int fgets(char* str, int num, char* delim = nullptr);
+  int fgets(char* str, int num, const char* delim = nullptr);
+  /** \return The first cluster number for a file or directory. */
+  Cluster_t firstCluster() const { return m_firstCluster; }
   /** \return The total number of bytes in a file. */
   uint32_t fileSize() const { return m_fileSize; }
   /** \return first sector of file or zero for empty file. */
diff --git a/src/FsLib/FsFile.h b/src/FsLib/FsFile.h
index fb516f8..2f80bc1 100644
--- a/src/FsLib/FsFile.h
+++ b/src/FsLib/FsFile.h
@@ -246,6 +246,12 @@ class FsBaseFile {
   uint64_t fileSize() const {
     return m_fFile ? m_fFile->fileSize() : m_xFile ? m_xFile->fileSize() : 0;
   }
+  /** \return The first cluster number for a file or directory. */
+  Cluster_t firstCluster() const {
+    return m_fFile   ? m_fFile->firstCluster()
+           : m_xFile ? m_xFile->firstCluster()
+                     : 0;
+  }
   /** \return Address of first sector or zero for empty file. */
-  uint32_t firstSector() const {
+  Sector_t firstSector() const {
     return m_fFile   ? m_fFile->firstSector()
@@ -864,6 +870,10 @@ class FsBaseFile {
            : m_xFile ? m_xFile->truncate(length)
                      : false;
   }
+  /** \return The valid number of bytes in a file. */
+  uint64_t validLength() const {
+    return m_fFile ? m_fFile->fileSize() : m_xFile ? m_xFile->validLength() : 0;
+  }
   /** Write a string to a file. Used by the Arduino Print class.
    * \param[in] str Pointer to the string.
    * Use getWriteError to check for errors.
